\clearpage
\begin{flushright}
	\textit{Лекция №22}
	\textit{2015.12.08}
\end{flushright}

Основа микроядерной архитектуры: сервисы операционный системы реализованы в собственных адресных пространствах. В микроядре остается функция непосредственного управления процессором.
2 функция микроядра связана с управлением памятью. Управление памятью в большинстве современных систем выполняется страницами по запросам. Самый нижний уровень управления памятью – выделение физической страницы.

Процессор и ОЗУ – суть компьютера. Остальное – внешнее устройство. В микроядре остаются низкоуровневые функции (обработка прерываний).

Планирование процессов может выполняться в режиме пользователя. Это пересчет приоритетов процессов в зависимости от различных ситуаций в системе.
Система с вытеснением: если пришел более приоритетный процесс, то он вытеснит выполняющийся процесс.

Менеджер памяти. Какие страницы можно вытеснить? А ядру дается команда на пейджинг.

Все ОС выполняют одни и те же функции из-за одинаковой архитектуры компов.
Микроядерная - крайне неэффективная архитектура, так как у нас есть предсказуемые задержки, как минимум в 2 раза из-за переключения полного контекста.
Почему интерес к микроядерным архитектурам не угасает? Поддается модификации без изменения кода ядра. Чтобы добавить новую функциональность – достаточно написать свой сервис. Благодаря возможности модификации без изменения всей ОС.
Реализовано в ОС Mach. 

\subsection{ОС Mach}

Оперирует набором абстракций. Базовые: процесс, поток. 
В Mach определены такие абстракции:
\begin{enumerate}
    \item процессы (имеет виртуальное адресное пространство; в этом ад. пр. находится код, данные и несколько стеков; процесс – единица декомпозиции системы, так как именно процесс является владельцем ресурсов);
    \item потоки (поток – непрерывная часть кода программа, которая может выполняться параллельно с другими частями кода; поток – независимо планируемый контекст выполнения, разделяющий единое адресное пространство процесса с другими потоками; единица планирования – поток; потоку принадлежит аппаратный контекст и счетчик команд; в процессе может быть один поток)
    \item объекты памяти (может состоять из 1 или несколько страниц; в основе управления памяти – кластеризация (заранее загрузим следующие страницы); составляет основу управления виртуальной памятью; выполняется страницами по запросам; для загрузки отсутствующей страницы посылается сообщение серверу памяти, который выполняется в режиме задачи, получив ответ от сервера, сможет выполнить загрузку нужных страниц в оперативную память) 
    \item порты – защищенный почтовый ящик, который способен поддерживать очередь сообщений. (очередь сообщений – упорядоченный список сообщений)
    \item сообщения (межпроцессное взаимодействие осуществляется с помощью сообщений; для передачи сообщений определена абстракция порт)
\end{enumerate} 


Система поддерживает несколько типов портов:
\begin{enumerate}
    \item порт процесса (используется для взаимодействия с ядром; многие функции ядра процесс вызывает путем отправки сообщений в порт процесса)
    \item порт загрузки (используется при старте системы; процесс init читает из порта загрузки инфо о именах .. обеспечивающие более важные сервисы) 
    \item порт особых ситуаций (используется при передаче сообщений об ошибках процессу)
    \item зарегистрированные порты (для взаимодействия процессов со стандартными в системе серверами; процесс может предоставить другому процессу посылать/получать сообщения через один из принадлежащих ему портов; такая возможность реализуется с помощью мандата, который включает указатель на порт и список прав которыми обладает другой процесс по отношению к данному порту; может выполнить команду send или только команду resive);
\end{enumerate} 

В Mach процесс может называться task.

\chapter{Операционные системы реального времени}
Операционные системы реального времени (ОСРВ) QNX.
Применять понятие реального времени к физическим устройствам бессмысленно. Мы и они живут в реальном времени. Это понятие возникло для операционных систем (может быть и ПО спец назначения). 

Понятие от Posix 1003.1:
реальное время в операционных системаx – способность операционной системы обеспечить требуемый уровень сервиса в определенный промежуток времени. 

Ключевым отличием ядра ОСРВ является детерминированность (основанный на строгом контроле времени). Детерминированность определяется тем, что они управляются внешними системами/устройствами. Они завязаны на характеристиках внешних устройств. Это и есть детерминированность. Её следствием  является требование обеспечения операционной системы соответствующих сервисов за определенные промежутки времени. Т.е. в ОСРВ главным критерием эффективность является обеспечение временных характеристик вычислительного процесса. Любая система реального времени должна реагировать на сигналы управляемого объекта в течении заданных временных ограничений. Очевидно – в ОСРВ планирование имеет особое значение.  Однако следует учитывать, что в ОСРВ как правило, набор выполняемых задач известен заранее. В ОСРВ часто имеется информация о временах выполнения задач, моментах активизации и предельных допустимых интервалах ожидания ответов. Такая информация может существовать в хорошо изученных/детерминированных системах. Достигается это путем выполнения большого кол-ва экспериментов с оценкой всех параметров системы. Также часто это достигается путем моделирования системы или эмуляции, когда одна операционная система работает как другая ОС. В результате снимаются все параметры тщательным образом. О системе реального времени известно все. В силу этого выбираются алгоритмы планирования, пересчет приоритетов. 

Различаются системы реального времени:
\begin{enumerate}
    \item гибкие (система резервирования билетов; если из-за временных задержек оператору не удается зарезервировать билет, это не страшно так как запрос может быть повторен); 
    \item жесткие (система управления атомным реактором; временные задержки/отказ системы недопустимы)
\end{enumerate} 

В системах реального времени использовались статические приоритеты. В настоящее время в ОСРВ используется подходы:
\begin{enumerate}
    \item статические приоритеты в зависимости от значимости процессов;
    \item динамические приоритеты (пересчитываются).
\end{enumerate} 

Классический алгоритм планирования независимых задач для жестких систем реального времени с одним процессором является \paragraph{алгоритм 1973 года Лью и Лейланд}. Основан на следующих предположениях:
\begin{enumerate}
    \item запросы на выполнение всех задач набора имеют жесткие временные ограничения на ответ системы и являются периодическими;
    \item все задачи – независимы. т.е. между любой парой задач не существует ограничений на порядок выполнения или взаимного исключения;
    \item срок выполнения каждой задачи равен её периоду $P_i$;
    \item максимальное время выполнения каждой задачи известно и постоянно $C_i$;
    \item время переключения контекста можно игнорировать;
    \item максимальный суммарный коэффициент загрузки процессора X $C_i/P_i$ при существовании $N$ задач не превосходит $N * (2^{1/n} – 1)$ при стремление N к бесконечности и приблизительно равно $ln(2)$, т.е. 0.7
\end{enumerate} 

Суть алгоритма: задачам назначаются статические приоритеты в зависимости от времени выполнения. Задачи с наименьшим временем получают наивысший приоритет. При соблюдении всех ограничений алгоритм гарантирует выполнение временных ограничений для всех задач для всех ситуаций. Если периоды повторения задач кратны периоду самой короткой задачи то требование к максимальному коэффициенту нагрузки процессора – смягчается, и он может доходить до единицы.

У Таненбаума это отображается следующей формулой:\\
$N$ процессов, $M$ периодических событий. Событие с номером $i$ поступает с периодом $p_i$ и на его обработку уходит время $c_i$. Тогда своевременную обработку всех потоков обеспечит выполнение след условия:
$$\sum_{i=1}^m ci/ pi \leq 1$$