\clearpage
\begin{flushright}
    \textit{Лекция №12}
    \textit{2015.10.20}
\end{flushright}

\section{Аппаратная реализация}

Если речь идет о об однопроцессорной системе, в которой параллельное выполнение происходит через квази-параллельность, то процесс выполняется до тех пор, пока им не будет запрошен сервис ОС или до прерывания. Если отменить прерывания на то время, пока процесс находится в КС, то обеспечивается взаимоисключение, но это невозможно.

В машине IBM370 машинная команда \verb|TEST_AND_SET| реализует однвоременную проверку  и установку содержимого ячейки памяти, которая называется \textbf{байт блокировки}. Эта команда является неделимой, т.е. последовательность действий, которую выполняет эта команда прервать нельзя. Она читает значение логической переменной $b$, копирует в $a$, устанавливает для $b$ значение "истинно".

Рассмотрим случай, когда процесс 1 (P1) хочет войти в КС, и прцоесс 2 (P2) уже в ней. P1 устанавливает C1 в 1 и входит в цикл проверки f. Т.к. P2 в КС, то f = 1. Т.о. P1 находится в своем цикле ожидания, пока P2 не выйдет из своего критического участка.

Этот способ реализации приводит к тому, что вероятность бесконечного откладывания очень мала, т.к. процесс выходит из КС и устанавливает флаг в false, то скорей всего другой процесс перехватит инициативу и сделает f = true.

\verb|TEST_AND_SET| машинная команда, используемая в спин блокировках. Спин блокировка - цикличекое выполнение проверки, обычно используется в ядре. Часто эта команда возвращает предыдущее значение объекта.

\begin{lstlisting}[language=c]
void spin_lock(spin_lock_t *c) {
	while (testandset(c) != 0) {}
}

void spin_unlock(spin_lock_t c) {
	c := 0;
}
\end{lstlisting}

\verb|TEST_AND_SET| в основных системах связана с блокирвокой шины данных. Но длительный уцикл может привести к занятию шины одной нитью и приведет к сущесвтенному снижению производительности системы. Решение - через 2 вложенных цикла.


\begin{lstlisting}[language=c]
void spin_lock(spin_lock_t *c) {
	while (testandset(c) != 0) {
		while (*c != 0) {}
	}
}
\end{lstlisting}

Если переменная занята, то выполняется вложенный цикл, в котором проверка переменной $C$  выполняется без захвата шины данных.

\section{Семафоры Дейкстры}

1965 год - первая работа Дейкстры, связанная с семафорами. Семафор - неотрицательная защищенная переменная $S >= 0$, на которой определены 2 операции $P(S)$ - пропустить, и $V(S)$ - освободить. Переменная защищена, т.к. м.б. изменена только тими двумя неделимыми операциями.

Семафор (0, 1) - бинарный.

Операция $P(S)$ - декремент. Процесс, вызвавший операцию $P(S)$ для $S = 0$ будет заблокирован на семафоре.

Операция $V(S)$ - инкремент, т.е. процесс разблокирует другой процесс, если было $S=0$.

Заблокированный процес не выполняет цикл активного ожидания, т.е. семафоры Дейкстры решили проблему активного ожидания. Но заблокировать/разблокировать процесс может только ядро. Вызов команд $P(S)$ и $V(S)$ приводит к переводу системы в режим ядра. Считающий семафор - принимает целые неотрицательные значения.

\begin{lstlisting}[language=c]
//P1: ...
P(S);
CR1;
V(S);

//P2: ...
P(S);
CR2;
V(S);
\end{lstlisting}
