\clearpage
\begin{flushright}
	\textit{Лекция №11}
	\textit{2016.05.16}
\end{flushright}

Куда делся флаг интеррапт? Все прерывания (кроме таймера) делятся на 2 части. Это подтверждается флагом irqtime2. Т.е. существует одно прерывание быстрое, оно от таймера. Флаг random скрытый, но на самом деле есть.  Флаг irqmapped разделяет ???.

Тасклет - обработчик отложенного дейсвтия. 
Обычная ошибка EBUSY означает, что данная линия прерывания уже используется или не указали irqfshared. \\
Ascii строка - текст, обозначающий соответствующее устройство. Этот текст - стринговая константа имени используется в $/proc/irq$, а также в $/proc/interrapt$ для указания пользователя.\\
параметр №5) $devid$ - используется для разделения линий irq. Важно понимать, что когда обработчик прерывания освобождается, именно поле $devid$ обеспечивает возможность указания уникального нашего файла, чтобы удалить только нужный обработчик прерывания с линии прерывания.
$freeirq(void *devid, int \text{линии})$\\
$devid$ - обработчик.

\lstinputlisting[language=c, caption={listing}]{listing/1.c} 

\section{Обработчики нижних половин}

\begin{lstlisting}
#define IRQF_TIMER (IRQF_TIMER | IRQF_NO_SUSPEND | IRQF_NO_THREAD)
// IRQF_NO_SUSPEND - не гарантируется, что это прерывание будет будить системы, не отключать этот запрос прерывания при остановке
// IRQF_NO_THREAD - прерывание не может быть запущено в виде потока
\end{lstlisting}

\paragraph{3 механизма реализации отложенного дейсвтия} необходимы для завершения обработки прерывания.
\begin{enumerate}
	\item softirq (гибкие);
	\item тасклеты;
	\item очереди работ (work queue).
\end{enumerate}	

\subsection{Soft irq}
определяются статически во время компиляции ядра. Описываются структурой $SOFT\_IRQ\_ACTION$. Эта структура представляет один вход.

\begin{lstlisting}
// тут объявлен статический массив 
// static struct softirq_action softirq_vec[32]
// т.е. таких обработчиков не может быть больше  32
#include <kernel/softirq.c>

struct softirq_action {
	// выполняемая функция
	void (*action) (struct *softirq_action *);

	// данные для функции
	void *data; 
}
\end{lstlisting}

\begin{table}[H]
\caption{Обработчики Softirq}
\begin{tabular}{|l|l|l|}
\hline
Инндекс & приоритет &  комментарий\\
\hline
HI\_SOFTIRQ & 0 & высокоприоритетный тасклет \\
TIMER\_SOFTIRQ  & 1 & таймеры\\
NET\_TX\_SOFTIRQ &  2 & отправка сетевых пакетов\\
NET\_RX\_SOFTIRQ &  3 & прием сетевых пакетов\\
SCSI\_SOFTIRQ &  4 & блочные устройства подситемы SCSI\\
TASKLET\_SOFTIRQ & 5 & тасклеты с обычным приоритетом \\
\hline
\end{tabular}
\end{table}

Чтобы заработал обработчик SOFTIRQ его нужно зарегистрировать. Регистрация происходит с помощью функции $OPEN\_SOFTIRQ(\text{3 парамета})$:
\begin{enumerate}
	\item индекс (один из таблицы)
	\item функция обработчик
	\item значения поля дата 
\end{enumerate}

Пример: $open\_softirq(NET\_TX\_SOFTIRQ, net\_tx\_action, NULL);$.

Чтобы обработчик обозначить в системе как ожидающий обработки, необходима функция $raise\_softirq(...)$

\begin{lstlisting}
static irqreturn_t xxx_interrupt(int irq, void *dev_id, struct pt_regs *regs) {
	//  ...
	raise_softirq(xxx_SOFTIRQ);
	return IRQ_HANDLED;
}

do_softirq() // вызывает в своем теле функцию do_softirq() которая реализована просто. Основной цикл этой функции: в системе есть очередь отложенных прерываний, проверяет их все и вызывает ожидающие обработчики.

do {
	if (pending &???) {
		h -> action(h);
	}
	h++;
	pending >>= 1;
} while (pending);
\end{lstlisting}

В системе имеется демон $KSOFTIRQD$ предназначенный для выполнения отложенных дейсвтий. При этом обработка отложенных действий типа $SOFTIRQ$ и тасклетов осуществляется с помощью набора потоков ядра по одному на каждый процессор. Если набрать $\# ps -Ahf | head -n12$ , то можно наблюдать следующее:

\begin{table}[H]
\caption{Обработчики Softirq}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
UID & PID & PPID & LWP & $\cdots$ & TTY\\
\hline
root & 1 & 0 & 1 & $\cdots$ & //sbin/init \\
$\cdots$ & $\cdots$ & $\cdots$ & $\cdots$ & $\cdots$ & $\cdots$\\
root & 1 & 2 & 4 & $\cdots$ & [KSOFTIRQ/0]\\
\hline
\end{tabular}
\end{table}

SOFTIRQ не могут переходить в состояние sleep. Если SOFTIRQ выполняется на процессоре, то его может вытеснить только аппаратное прерывание. Одно и тоже IRQ может параллельно выполняться на разных процессорах. Код должен быть реентабельным, следовательно код меньше простаивает в очереди.

\subsection{Тасклеты}
Тасклет - частный случай SOFTIRQ, реализуется на базе SOFTIRQ. Тасклеты - отложенные прерывания, для которых установлено следующее правило: один и тот же тасклет не может выполняться несколькими процессорами. Тасклеты разных типов могут параллельно выполняться.

Тасклет - компромисс простоты использования и быстроты. 

Статические макросы создаются в виде макросов в файле $linux/interrupt.h$:
\begin{enumerate}
	\item $DECLARE\_TASKLET(name, func, data);$ - создает тасклетЮ у которого счетчик ссылок равно 0.
	\item $DECLARE\_TASKLET\_DISABLED(name, func, data);$ - поле ссылок равно 1 и запрещен.
\end{enumerate}

Могут быть созданы динамически с помощью функции $TASKLET\_INIT$
\begin{lstlisting}
struct tasklet *taskl;
tasklet_init(taskl, taskl_handler, data);
\end{lstlisting}

Чтобы запланировать выполнение тасклета вызывается либо $tasklet\_shedule()$ либо $tasklet\_hi\_shedule()$ и передается 1 параметр на структурау $tasklet_struct$.
\begin{lstlisting}[caption = Структура $tasklet\_struct$]
struct tasklet_struct {
	struct tasklet_struct *next;

	// текущее состояние
	unsigned long state;

	// счетчик ссылок 
	atomic_t count;
	
	void (*func) (unsigned long);
	unsigned long data;
};
\end{lstlisting}

Поле $state$ может иметь 1 из 2 состояний: $TASKLET\_STATE\_SHED$ и $TASKLET\_STATE\_RUN$.

Запланированные на выполнение тасклеты хранятся в связных списках: $TASKLET\_VEC$ и $TASKLET\_HI\_VEC$.

После планирования тасклет будет запущен 1 раз, даже если добавлен несколько раз, в отличие от $SOFTIRQ$.

Для отключения тасклета используются:
\begin{enumerate}
	\item $tasklet\_disable()$ не сможет отменить тасклет, который уже выполняется;
	\item $tasklet\_disable\_nosync()$ сможет.
\end{enumerate}

$void tasklet_handler(unsigned long data)$ - функция обработки тасклета.

Особенностью тасклетов является то, что они не могут блокироваться, поэтому в них нельзя испоользовать семафоры. Если в тасклете используются общие данные с обработчиком прерывания или другим тасклетом, то нужно использовать spin блокировки.

\subsection{Очереди работ (work queue)}
Построены на базе task queue.

$\# cat /proc/interrupt$ - чтобы посмотреть прерывания, доступные в системе.

Для идентификации драйвера устройства в системе зарезервированы старшие номера для обычных (партикулярных) устройств. Другие старшие номера могут динамически связываться, когда загружается linux. 

Старший номер 94 - всегда DASD Device (Direct access stored device) - вторичная память: ЖД, ленточные диски, оптические.
Старшие номера могут разделяться, т.е. один и тот же старший номер может использоваться множеством драйверов устройств.
$\# cat /proc/devices$ - чтобы посмотреть старишие номер в системе.

Младшие номера используются, чтобы драйверы отличали различные физические/логические устройства. DASD имеет 4 младших номера.