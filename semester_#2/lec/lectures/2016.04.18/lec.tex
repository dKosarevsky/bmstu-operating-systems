\clearpage
\begin{flushright}
	\textit{Лекция №9}
	\textit{2016.04.18}
\end{flushright}

\section{Проблема реализации spin блокировок в windows.}

Пусть на уровне passive захвачена spin блокировка, соответственно по истечении кванта, какой-то поток на уровне dpsdispatch пытается захватить блокировку. В результате поток, выполняющийся на  dps/dispatch крутится  в ожидании блокировки, но переключения потоков не будет, диспетчер не может вызваться. В итоге - бесконечное ожидание.
Представим такую ситуацию, код работающий на уровене ??? захвтаил спин блокировку, чтобы безопасно изменить какие то параметры. Затем вызван код на dps/dispatch, который, пытаясь захватить спин блокировку, войдет в бесконечное ожидание. Этот цикл не закончится, так как код, захвативаший блокировку, имеет более низкий уровень irql и не будет иметь возможность выполниться.
Чтобы таких ситуаций не возникало в системе Windows предусмотрено повышение текущего уровня irql в момент захвата спин блокировки до уровня irql сопоставленного  со спин блокировкой. После освобождения spin блокировки старый уровень irql восстанавливается. Со спин блокировками связан уровень irql. Из сказанного следует, что код, работающий на повышенном уровне irql не может обращаться к ресурсу, защищенному спин блокировкой, если уровень irql спин блокировки ниже уровня irql кода , который пытается к нему обратиться.

В винде два вида спин блоккировок:
\begin{enumerate}
	\item обычные. С ними связан irql dispatch level. Поэтому, все попытки их захвата должны выполняться на уровне irql меньше или равном dispatch level.
	\item синхронизации прерываний. C ними связан один из уровней device irql.
\end{enumerate}	

\paragraph{Системные вызовы, связанные с обычными вызовами ???}

\begin{enumerate}
	\item $void KeInitializeSpinLock(IN PKSPIN\_LOCK SpinLock);$ - функция инициализирует объект ядра KSPIN\_LOCK. Память под спин блокировку должна быть выделена в невыгражаемой памяти.
	\item $void KeAcquireSPinLock(In PKSPIN\_LOCK SpinLock, OUT PKIRQL OldIrql)$ - ф-я захватывает спин блокировку, причем не возвращает управление до успешного захвата блокирвоки. Уровень irql  повышается до уровня dispatch level. OldIrql - показывает уровень irql который был до захвата блокировки.
	\item $void KeReleaseSpinLock(IN PKSPINJLOCK SpinLock, OUT PKIRQL NewIrql);$ - ф-я освобождает спин блокировку и устанавливает уровень irql которое было запомнено
	\item $void KeAcquireLockAtDpeLevel(IN PKSPIN\_LOCK SpinLock)$ - оптимизированная фу-я, уже работает на уровне dispatch level и изменения уровня irql не требуется. На однопроцессорной машине она ни че не делает, так как синхронизация обеспечивается самой архитектурой irql.
	\item $void KeReleaseLockFromDpcLevel(IN PKSPIN\_LOCK SpinLock);$ - парная функция releaze lock from dpc level
\end{enumerate}	

\paragraph{Пример}
В драйвере можем запустить доп поток/и. Драйверы используют спин блокировки для доступа к структурам данным.
\lstinputlisting[language=c, caption={listing}]{listing/1.c} 

Прерывания irql и dpc называются программными и генерируются ядром и драйверами устройств. На эти прерывания имеются след ограничения:
\begin{enumerate}
	\item код выполняемый на уровне dpc и выше не может ждать освобождения объекта, если такое ожидание влечет переключение потока, так как планировщик на этом уровне не может быть активизирован без переключения потоков.
	\item на уровене dpc и выше доступно  только неподкачиваемая память (non paging). Явлется следствием первого пункта, так как чтобы реализовать подкачку необходимо вызвать менеджер памяти.
\end{enumerate}

В виндах есть спин блокировки с очередями (queued spinlock), которые лучше масштабируются в многопроцессорных системах. Спин блокировка с очередью работает следующим образом: 
\begin{enumerate}
	\item процессор, пытаясь установить qsl, который занят, ставит свой идентификатор в очередь к ней.
	\item процессор освобождая qsl передает её первому процессору в очереди.
	\item процессор , ожидающий qsl проверяет статус не самой спин блокировки, а флага того процессора,  который находится в очереди непосредственно перед идентификатором ждущего процессора. 
\end{enumerate}

Факт установки флага, а не глобальной блокировки имеет два следствия:
\begin{enumerate}
	\item уменьшается интенстивность трафика, связанного с межпроцессорной  синхронизацией.
	\item выбор процессора по FIFO
\end{enumerate}

PCR (processor control region) каждого процессора. 

Глобальную спин блокировку с очередью можно получить вызвав $KeAcquizeQueuedSpinLock();$ 
Есть еще внутристековые спин блокировки с очередями.

\section{О предписании порядка выполнения}
Речь идет о переупорядочивания. Если произойдет редкий случай, то придется сбрасывать весь конвеер, что я вляется дорогим удовольствием.
\lstinputlisting[language=c, caption={listing}]{listing/2.c} 

Lockless programming – программирование, максимально освобожденное от блокировок. Проблема возникает, потому что мы с вами живем в эре параллельного программирования, при этом  если в коде возникают участки, защищенные блокировками, то такие участки кода будут выполняться последовательно.

Когда разрабатывается ПО свободное от блокировок, то имеется 2 проблемы, с которыми мы так или иначе имеем дело:
\begin{enumerate}
	\item взаимоблокировки
	\item переупорядочивание reodering
\end{enumerate}

При этом надо помнить, что чтение/запись типов, которые не выровнены естественно и выходят за пределы 4 байт не будут атомарными. Часто для кода имеет значения порядок выполнения операций. Это называется специальным термином ordering. Атомарность гарантирует, что операции выполняются не прерываясь. Odering гарантирует что две и более операции всегда выполняются в нужном порядке, даже если они выполняются разными потоками или процессами.

\paragraph{Пример}

\begin{lstlisting}[caption=listing, label=code_reodering]
a = 1;
b = 2;
\end{lstlisting}

Мы не можем гарантирвоать, что \ref{code_reodering} будут выполнены в этом порядке, потому что порядок выполнения может изменить:
\begin{enumerate}
	\item компилятор из соображений оптимизации.
	\item процессор из соображений аппаратной оптимизации работы с шиной памяти.
\end{enumerate}

Это не касается операций, записанных в едином контексте, так как компилятор видит, что \ref{code_odering}  единый фрагмент кода, но если это выполняется в разных потоках, то компилятор это не увидит.

\begin{lstlisting}[caption=listing, label=code_odering]
a = 1;
b = a + 1;
\end{lstlisting}

\subsection{Барьеры памяти}
Порядок выполнения гарантируется с помощью операций, которые называются барьерами. Макрос барьеры объявлен в $<linux/compiler.h>$. Этот макрос препятствует компилятору менять порядок следования операций (т.е. выполнять reodering). Этот макрос - $void barrier(void);$. 

Кроме данного макроса в linux определены барьеры для выполнений операций с памятью.
\begin{lstlisting}[caption=listing, label=code_macros_rw_bar_mem]
#include <asm/system.h> 

//read memory barrier
void rmb(void);

void wmb(void);

//read/write
void mb(void);
\end{lstlisting}

Данные макросы \ref{code_macros_rw_bar_mem} работают следующим образом: после вызова операций с памятью ,не выполняются, пока не будут завершены все операции с памятью до вызова функций.

\begin{lstlisting}
//Начальные значения
a = 1;
b = 2;

//Поток 1:
a = 3;
mb();
b = 4

//Поток 2:
с = 4;
rmb();
d = a;
\end{lstlisting}

Функции $mb()$ $rmb()$ заставят процессор выполнять все незаконченные оперции чтения и записи перед тем как закончить работу.

Это не полный перечнь функций. Следует отметить, что для разных аппаратных платформ эффект от установки барьеров может быть разным.