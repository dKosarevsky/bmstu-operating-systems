\clearpage
\begin{flushright}
	\textit{Лекция №6}
	\textit{2016.03.28}
\end{flushright}

\lstinputlisting[language=c, label=code_read_proc, caption=Пример процедуры чтения]{listing/1.c} 

В \ref{code_read_proc} создаем 1 функцию copy\_to\_user (эта функция на первом этапе выполняет вызов ф-и access\_ok() )

Функция access\_ok(type, addr, size)   проверяет, действительно ли существует указатель на пространство пользователя, к которому необходимо получить доступ. Вызывается в тексте функции. Имеет 3 параметра: указатель на начала блока памяти, размер блока и права доступа. type: VERIFY\_READ  или VERIFY\_WRITE (предполагает  VERIFY\_READ). Адресное пространство процессов защищены и виртуальны. ФС proc позволяет взаимодействовать с адресным пространством ядра и делается это через буфера. Буфера могут быть объявлены как указатель на buf или на page. 

Загружаемые модули ядра пишутся по определенным правилам: в текст модуля обязательно должны быть включены два макроса (module\_init module\_exit: они регистрируют нашу функцию). Макросы вставляются в текст. В отличии от функций, которые имеют собственное адреcное пространство, макросы являются вставками в текст какой то программы, мы не перекомпилируем ядро, но тем не менее это вставка. В разных примерах по разному регистрируются call-back функции. Тут, функция read (наша, чтения виртуального файла) регистрируется через ???
Необязательно использовать copy\_to\_user (пример - когда используется mem\_copy()).  Существуют разные способы взаимодействия с виртуальными файлами: есть ФС proc, есть ФС proc\_fs.
Кроме copy\_to\_user() copy\_from\_user() упоминаются еще get\_user() put\_user().

\lstinputlisting[language=c, label=code_mem_copy, caption={Пример, когда используется mem\_copy()}]{listing/2.c} 

В \ref{code_mem_copy} - пример создания файла в proc. Для функции write должны обеспечить импортирование данных, так как они приходят из пространства пользователя. Для функции read , т.к. данные уже находятся в пространстве ядра. 

\lstinputlisting[language=c, label=code_define_proc_dir_entry, caption={Еще пример}]{listing/3.c}

В \ref{code_define_proc_dir_entry} видим определение полей структуры proc\_dir\_entry.

В самом тексте фортунок используется sprintf (по тем же соображениям что и mem\_copy). Сами фортунки служат вспомогательным примером.


\chapter{Взаимоисключения ядра}

(после этого будем рассматривать прерывания и пример драйвера. Драйвер реализуется в виде загружаемого модуля ядра и самым распространенным примером является пример USB хит driver)

Примером, на сколько важен монопольный доступ к разделяемым данным, является взаимодейсвтие паралельных процессов (безразлично квази или реально параллельные).

\paragraph{Пример: два параллельных  процесса пытаются добавить в очередь новый элемент}

Каждый из процессов пытаются записать в очередь (связный список) свою структуру
\begin{lstlisting}[caption=Структура queue]
struct queue {
	int data;
	struct queue *next;
}
\end{lstlisting}


\begin{table}[H]
\begin{tabular}{|l|l|}
\hline
p1: & p2: \\
\hline
new(a); & \\
a->next = q->next;  & \\
\hline
\multicolumn{2}{|c|}{прервали p1} \\
\hline
 & new(b); \\
 & b->next = q->next; \\
 & q->next = b; \\
\hline
\multicolumn{2}{|c|}{возобновили p1} \\
\hline
q->next = a; & \\
\hline
\end{tabular}
\end{table}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{pic/1.png}
  \caption{pic}
\end{figure}

Необходимо предоставлять монопольный доступ.

Спин блокировки – строятся на основе команды test\_and\_set или test\_and\_set\_lock. Lock – слово в памяти.




