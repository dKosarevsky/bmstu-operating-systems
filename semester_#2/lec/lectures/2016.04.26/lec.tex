\clearpage
\begin{flushright}
	\textit{Лекция №10}
	\textit{2016.04.26}
\end{flushright}

\chapter{Прерывания}

Каталог $/dev$ - это не файловая система как $/proc$, это каталог специальных файлов: fd0, lp0, null, mem, mouse … Специальные файлы обеспечивают доступ к переферийным устройствам. Эти файлы обеспечивают связь между файловой системой и драйверами устройств. Такая интерпретация спец файлов обеспечивает доступ к внешним устройствам, как к обычным файлам. Аналогично обычному файлу с использованием тех же системных вызовов файл устройства может быть открыт/закрыт , в него можно писать/читать. Каждому внешнему устройству UNIX/Linux ставит в соответствие как минимум один специальный файл. Связь имени файла и устройства обеспечивает индексный дескриптор.

Подкатолог $/dev/fd$ содержит файлы с именами 0, 1, 2, ... В некоторых системах имеются файлы с именами
$/dev/stdin$, $/dev/stdout$, $/dev/strerr$ которые эквивалентны $/dev/fd/0$, $/dev/fd/1$, $/dev/fd/2$.

\paragraph{Драйвер}

Драйвер - это программа, или часть кода кода ядра, которая предназначена для управления конкретным устройством. Обычно драйверы устройств содержат последовательность команд, специфичных для конкретного устройства. Поскольку драйвер предназначен управления устройством, то код должен соответствовать специфике устройства. Обычно это связано с форматом передачи данных от системы к устройству и обратно. Если не знаем форматы данных , то управлять таким устройством мы не сможем.

В линукс драйверы устройств бывают трех типов:
\begin{enumerate}
	\item встроенные в ядро
	\item реализованные как загружаемые модули ядра
	\item код  драйверов этого типа поделен между ядром и специальной утилитой
\end{enumerate}

\textbf {драйверы, встроенные в ядро} Соответствующее устройство автоматически обнаруживаются системой и становятся доступными приложениям. Примером таких устройств являются: VGA, IDE контроллеры, мат плата, последовательные и параллельные порты. В наших системах имеется 2 адресных простарнства: адресное простарнство оперативной памяти и портов ввода/вывода. Порт – это адрес. Точно также как минимальной адресуемой ядиницей памяти является байт, порта - тоже байт.  Внешние устройства используют 2 схемы: memory mapping (адресация устройства выполняется аналогично адресации памяти, т.е. используются команды работы с оперативной памяти. К таким устройствам относят видеокарты), input/output mapping (внешние устройства подключаются к системе через порты ввода ввода. Две команды in/out).

\textbf {драйверы, реализованные как загружаемые модули ядра} Файлы модуля ядра располагаются в $/lib/modules$. Обычно, при инсталяции системы задается список модулей, которые будут автоматически подключаться на этапе загрузки. Спиcок загружаемых модулей хранится в файле $/etc/modules$

\textbf {код  драйверов этого типа поделен между ядром и специальной утилитой} Например в драйвере принтера ядро отвечает за взаимодействие с параллельным портом, а формирование управляющих сигналов осуществляет демон печати lpd, который использует для этого специальную программу фильтр. Еще пример драйвера – драйвер модема.

В линукс файлы устройств идентифицируются двумя положительным ичислами:
\begin{enumerate}
	\item major device number
	\item minor device number
\end{enumerate}

\textbf {major device number} - старший номер устройства. Индентфиицирует тип устройства (чаще говорят драйвер устрйоства). Например звуковая плата, жесткий диск. Текущий список старших номеров устрйоств можно найти в файле $/usr/include/linux/major.h$

\begin{table}[H]
\begin{tabular}{|l|l|}
\hline
старший номер & тип устройства\\
\hline
1 & оперативная паямть \\
2 & гиб диск \\
13 & мышь \\
14 & звуковая карта\\
\hline
\end{tabular}
\end{table}

Файлы устройств одного типа имеют одинаковые номера и отличаются по номеру, который добавляется в конец имени. Все файлы сетевых плат имеют имена Ethernet->eth: eth0, eth1,…

\textbf {minor device number} - идентифицируют конкретные устройства в ряду устройств с одим и тем же старшим номером. Если перейти в каталог /dev и выполнить команду ls –l то в место размера файла в байтах мы увиди два числа, разделенных запятой (старший и младший номера).

$\# ls –l /dev/ | grep "^ c"$ - выведет файлы символьных устрйоств.

$\# cat /proc/devices$ - выведется информация о старших номерах устройств, известных ядру.

В $linux/types.h$ определен тип $dev\_t$ который содержит старшие и младшие номера. Размер соответствующего значения 32бит: 12бит – старший номер, 20бит – младший.

В $linux/kdec\_t.h $ определены два макроса: \verb|MAJOR (dev_t dev)| и \verb|MINOR(dev_t dev)|.
Если известен старший и младший номера устрйоств, и нужно получить $dev\_t$, то для этого используется макрос
\verb|MKDEV(int major, int minor)|

\begin{lstlisting}[caption=Печать старшего и младшего номера устройства]
static dev_t first;
printk(KERN_INFO "<major, minor> : <%d,%d>/n", MAJOR(first), MINOR(first));
\end{lstlisting}

\section{Обработчики прерываний}
message signaled interrupt – это альтернативный вид прерываний, замещающий векторные прерываний.
В случае MSI вместо использования линий прерываний используются MSI прерывания, которые записываются в определенное место памяти (по определеннму адресу) такое сообщение не может быть отправлено неизвестно куда. Для записи этого сообщения используется bus mastering, т.е. механизм захвата шины. Для записи MSI каждое устройство может иметь от одной до 32 закрепленных за ней областей памяти. При этом если посмотреть вывод на экран то таймер - это по прежнему линия 0. APIC. Остаются фиксированные номера. 

Достоинства MSI:
\begin{enumerate}
	\item возможность передачи дополнительных данных вместе с информацией о наступлении события. Это избавляет обработчик прерывания от необходимости считывать данную информацию из регистров состояния устройства, что уменьшает нагрузку на шину.
	\item возможность полного отказа от линий управления INT, которые связаны с устройствоми разьемов  PCI до контроллера APIC, что упрощает материснкую плату (кол-во соединений).
	\item в многопроцессорных/многоядерных системах устройства получают возможность самостоятельно выбирать процессор/ядро для обработки конкретного прерывания. Причем делается это на уровне аппаратуры. Это особенно важно для систем, которые называются NUMA – non uniform memory access (системы с неравномерным доступом к памяти). Является альтернативой SNP арихитектур. Наиболее часто используется версия ccNUMA – cache coherent NUMA это система, в которой ядра работают с собственной локальной памятью.
\end{enumerate}	

\section{Регистрация обработчиков прерываний}

Каждое устрйоство имеет один драйвер и регистрирует один обработчик прерывания. Драйверы могут регистрировать один обработчик прерываний и разрешать определенную линию прерываний, связанную с этим обработчиком. 

\begin{lstlisting}[caption=listing, label=code_reg_inter]
int request_irq(unsigned int irq, irqreturn_t (*handler)(int, void *, struct pr_regs *), unsigned long irqflags, const char *devname, void *dev_id) 
\end{lstlisting}

Обработчик прерывания регистрируется регистрируется функцией \ref{code_reg_inter}.
$irq$ – определяет номер прерывания. Для некоторых устройств (legacy device: таких как системный таймер или клавиатура) эта величина обычно устанавливается аппаратно. Для большинства других устройств она определяется программно, и динамически (в соответствии с требованиями системы). 
$handler$ – указатель на код обработчика прерывания который обслуживает данное прерывание.

\begin{lstlisting}[caption=listing, label=code_work_inter]
static irqreturn_t intr_handler(int irq, void *dev_id, struct pt_regs *regs);
\end{lstlisting}

Функция \ref{code_work_inter} вызывается когда происходит прерывание. Принимает 3 параметра:\\
$int irq$ - числовое значение линии прерывания.\\
$dev\_id$ – общий указатель на $dev\_id$ который указывается в $request\_irq$.  Если значение это уникальное в системе, то оно выполняет роль дифференциатора между множеством устройств, которые потенциально могут использовать один обработчик прерывания. Может также указывать на структуру, используемую обработчиком прерывания, т.к. структура $device$ уникальная для каждого устройства и используется в обработчике то она обычно передается для $dev\_id$.\\
$regs$ – содержит указатель на структу, содержащий регистры процессора, котрые определяют состояние до обслуживания прерывания. Этот параметр используется для отладки.\\

Возвращаемое значение имеет тип  $irqreturn\_t$ это м.б. два значения:\\
$IRQ\_NONE$ если обработчик прерывания обнаруживает что устройство, за которым он озакреплено его не инициировало. \\
$IRQ\_HANDLER$ – когда обработчик прерывания был корректно вызван, т.е. устройства, за которым этот обработчик закреплен, действительно сформировало прерывание. 

$irqflags$ – м.б. 0 или битовой маской одного или нескольких флагов. Определены след. флаги:\\
$SA\_INTERRUPT$ – определяет обработчик прерыавания, который является fast interrupt, т.е. быстрым прерыванием. Исторчиески linux различает быстрые и медленные обработчики прерываний. Быстрые должны выполняться быстро, но очень часто флаг устанавливается для выполнения прерывания, чтобы разрешить ему выполняться так быстро, как он может. В настоящее время есть только одно отличие: быстрые прерывания выполняеются при запрете всех прерываний на локальном процессоре, что немаловажно для быстрого завершения прерывания. Если флаг сброшен, то это не быстрое прерывание и все прерывания разрешены за исключением замаскированных на всех прцоессорах. Прерывание от системного таймера - это быстрое прерывание.\\
$SA\_SAMPLE\_RANDOM$ – определяет, что прерываание, генерируемые устрйоством, должны вносить свой вклад в пулл ентропии. Этот пулл в ядре генерирует случайные числа. Большинство устройств генерируют прерывание в случайные промежутки времени (исключяя системный таймер и сетевые устройства, подверженные внешним атакам)  