\clearpage
\begin{flushright}
	\textit{Лекция №7}
	\textit{2016.04.04}
\end{flushright}

\section{Атомарные операции. Атомарность.}

Атомарные операции могу предоставляться ОС или средой программирования.

Lockless – свободный от блокировок. Любая блокировка это перевод потока/процесса в состояние блокировки, что связано с двумя переходами в режим ядра и задержками выполнения программного кода. Поэтому обсуждается программирование свободное от блокировок \cite{Dawson_Lockless}

Проблемы возникающий при разработке ПО свободного от блокировок:
\begin{enumerate}
	\item Неатомарные операции. Non-atomic
	\item Переупорядочивание. Reordering
\end{enumerate}

На x86 операция чтения/записи является атомарной только в случае если тип данных соответствует размеру шины данных. Чтение/запись типов,  которые не выровнены (например типа dword, выходящих за 4 байта) не будет атомарным. Атомарность гарантируется только для перемещений данных размерность типа которых соответствует размерности шины данных.

В различных ОС предлагаются различные атомарные операции:
\begin{enumerate}
	\item Windows: группа interlocked функций
	\item Linux: группа atomic функций
	\item .NET: класс System.Threading.Interlocked
\end{enumerate}

\paragraph{Неделимые битовые операции}
Если два потока выполняются на двух процессорах и пытаются одновременно произвести дейсвтие над одним и тем же битом, то свойство неделимости оперцаии даст возможность сделать это только последовательно. Атомарные неделимые дейсвтия являются неделимыми даже при возникновения прерывания. Если прерывание возникнет, то оно будет обработано только после завершения команды. 
\begin{enumerate}
	\item $test\_and\_set\_bit(nr, void *addr)$ - устанавливает в беззнаковом двойном слове бит с номером nr. Возвращает предыдущее значение бита. после завершения выполнения команды бит станет равным 1. Возвращаемое значение показывает предыдущее значение. Если команда возвращает 1, то вызвавшая её нить ???.
	\item $test\_and\_clear\_bit(nr, void *addr)$ - освобождение ресурса производится сбросом бита в ноль
	\item $test\_and\_change\_bit(nr, void *addr)$ инвертирует бит
	\item $set\_bit(nr, void *addr)$ устанавливает бит (в 1)
	\item $clear\_bit(nr, void *addr)$ сбрасывает (в 0)
	\item $change\_bit()$
	\item $test\_bit()$
\end{enumerate}

\paragraph{Атомарные операции над целыми числами}
atomic\_t соответствует типу int
\begin{enumerate}
	\item $atomic\_set(atomic\_t *var, int i)$ устанавливает значение переменной в i
	\item $atomic\_read(atomic\_t *var)$ считывает переменную в var.
	\item $atomic\_add / atomic\_sub(int i, atomic\_t *var)$ сложение/вычитание
	\item $atomic\_inc / atomic\_dec(atomic\_t *var)$ 
\end{enumerate}

\section{Spin блокировки}

Для защиты больших участков кода используются spin блокировки и семафоры. 
В ядре Linux реализуются spin\_lock\_t, который также соответствует типу integer. Всё это чудо в <asm/spinlock.h>  

bh – buttom half.

\paragraph{Набор функций для захвата spin блокировок}
\begin{enumerate}
	\item $spin\_lock(spinlock\_t *my\_spinlock)$ – захватываем spin блокировку, гарантирую взаимоисключение.
	\item $spin\_lock\_irqsave(spinlock\_t *my\_spinlock, unsigned long flags)$ – блокирует вход в крит участок и предотвращает возникновение прерываний и сохраняет регистр состояния процессора в переменной flags. 
	\item $spin\_lock\_irq(spinlock\_t *my\_spinlock)$ та же, но не рекомендуется, так как не сохраняет регистр состояния процессора. Этот тип блокировки можно использовать, если перед её захватом прерывания были разрешены и при её освобождении прерывания можно просто разрешить. Перед захватом необходимо убедиться что прерывания разрешены. 
	\item $spin\_lock\_bh(spinlock\_t *my\_spinlock)$ пытается установить блокировку и одновременно предотврощает запуск нижних половин обработчиков прерываний. 
\end{enumerate}

\paragraph{Команды освобождения spin блокировок}
\begin{enumerate}
	\item $spin\_unlock(spinlock\_t *my\_spinlock)$
	\item $spin\_unlock\_irqrestote(spinlock\_t *my\_spinlock, unsigned long flags)$ – освобождает spin блокировку и разрешает прерывания, если прерывания были разрешены, иначе прерывания не разрешаются. Сохранение регистра состояния процессора CR0. 
	\item $spin\_unlock\_irq (spinlock\_t *my\_spinlock)$ при вызове этой команды освобождается spin блокировка и разрешаются прерывания. Можно вызывать только если прерывания были разрешены, иначе возникнет ошибка.
	\item $spin\_unlock\_bh(spinlock\_t *my\_spinlock)$ освобождает блокировку и разрешает немедленную обработку нижних половин прерываний.
\end{enumerate} 

\lstinputlisting[language=c, caption={Пример про связный список (на экзамен)}]{listing/1.c} 

\paragraph{Дополнительные функции со spin блокировками}
\begin{enumerate}
	\item $spin\_is\_locked(spinlock\_t *my\_spinlock)$ получает текущее значение spin блокировки. При этом её состояние не меняется. Возвращает не ноль, если spin блокировка захвачена. 
	\item $spin\_try\_lock(...)$ пытается захватить блокировку. Если блокировка уже захвачена то вместо циклической проверки ожидания освобождения функция сразу возвращает не нулевое значение. Т.е. не входит в цикл активного ожидания.
	\item $spin\_unlock\_wait(...)$  ожидает освобождения спин-блокировки. (ожидание связано с блокировкой ???)
	\item $spin\_lock$ – активное ожидание на процессоре.
	\item $spin\_lock\_init(...)$ инициализирует динамически созданные спин-блокировки. В примере – статическая инициализация. Динамически – в процессе выполнения программного кода. 
\end{enumerate} 

\paragraph{Spin-блокировки чтения/записи}

Для их реализации используется структура $rwlock\_t$. Были созданы исходя из того факта, что сами спин-блокировки предполагают активное ожидание и их использование замедляет выполнение программы, при этом часто возникают ситуации, в которых структуры данных активно считываются и довольно редко редактируются.  Примером того может служить список зарегистрированных сетевых устройств $dev\_base$. Этот список часто читают, но редко модифицируют. Поэтому предлагается использовать специальные спин блокировки чтения/записи. Блокировку по чтению могут одновременно захватить несколько потоков, которые выполняют чтение. Блокировку по записи может захватить только один поток, при этом чтение данных запрещено. 

Перечислим эти функции:
\begin{enumerate}
	\item $read\_lock(rwlock\_t *my\_rwlock)$
	\item $write\_lock(rwlock\_t *my\_rwlock)$
	\item $rw\_lock\_init(...)$
	\item $read\_unlock(...)$
	\item $write\_unlock(...)$
	\item $read\_lock\_irq(...)$
	\item $read\_lock\_irqsave(rwlock\_t *my\_rwlock, unsigned long flags)$
	\item $read\_lock\_bh(...)$
	\item тоже самое для write
\end{enumerate}

\paragraph{Реализация spinlock}

реализуются на базе команд $test\_and\_set$

\begin{lstlisting}[label=impl_spin_lock, caption=Реализация spin\_lock]
void spin_lock(spinlock_t *s) {
	while (test_and_set(s) != 0) { //занят
		while (*s != 0) {}
	}
}
\end{lstlisting}

Шина памяти не может быть блокирована на длительное время, поэтому циклический вызов $test\_and\_set(s) $заменяется на проверку $while (*s != 0)$ .Выполнение команды $test\_and\_set$ атомарно и такая операция будет занимать 1 транзакцию шину, но здесь эти транзакции предполагаются в цикле и они заменяются проверкой переменной s  без захвата шины. 

\begin{lstlisting}[label=impl_spin_unlock, caption=Реализация spin\_unlock]
void spin_unlock (spinlock_t *s) {
	*s = 0;
}
\end{lstlisting}

На однопроцессорной машине не компилируются в ядре: например $spin\_lock$??? только запрещает прерывания. 

\paragraph{Когда разумно использовать spin блокировки.}

Блокировки связаны с переключением контекста. Переключение контекста затратное действие, как минимум будет выполнено два переключения контекста. Поэтому считается, что использовать spin блокировки разумно если она удерживается время, которое меньше или равно времени двух переключений контекста. Очевидно, что сама такая оценка проблематична.
Разработчики ПО просто должны учитывать факт активного ожидания и удерживать spin блокировки по возможности в течении максимально короткого интервала времени. В многопроцессорных системах, время, в течении которого удерживаются spin блокировки эквивалентно времени задержки системного планировщика.

