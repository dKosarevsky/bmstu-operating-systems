Компилить через:
sudo make -C /usr/src/linux-headers-`uname -r` SUBDIRS=$PWD modules
(проверялось на Дебиане с ядром версии 3.2.65, у вас может отличаться путь)

Запускать ^ команду в папке с *.c файлом и Makefile (название Makefile - обязательно с большой буквы!)
Результат выполнения команды - файл lab3.ko

Подключение модуля - sudo insmod lab3.ko
Отключение модуля - sudo rmmod lab3.ko

Чтение логов ядра: sudo dmesg
Все сообщения в логах начинаются с lab3, можно погрепать, чтобы не читать кучу лишнего:
sudo dmesg | grep lab3

Отправить текст проге: echo <текст> > /proc/lab3 (например: echo 1 > /proc/lab3)
Считать вывод проги: cat /proc/lab3

Прога при попытке записи добавляет в буфер указанное количество случайных символов (echo 1 - один, echo 10 - десять...)
при считывании печатает буфер и очищает его. При попытке переполнить буфер дальнейший ввод блокируется.

При попытке "отправки текста" будет вызвана функция fortune_write, при считывании - fortune_read
Функционал лучше поменять, чтобы Рязанова не придралась

СТАНДАРТНУЮ БИБЛИОТЕКУ В МОДУЛЯХ ЯДРА ИСПОЛЬЗОВАТЬ НЕЛЬЗЯ!
Нужно что-то из неё - гуглите аналог этой функции в ядре или напишите замену сами

Полезные функции:

linux/kernel.h:
printk(<уровень важности> <форматная строка>, ...) - записать сообщение в логи ядра.
Пример:
printk (KERN_DEBUG "lab3 debug: %d", res);

Интересные нам уровни важности:
KERN_ERR - ошибка
KERN_INFO - информационное сообщение
KERN_DEBUG - отладочная информация

linux/random.h:
get_random_bytes (void* ptr, int num) - записывает по указателю указанное количество случаныйх байт

asm/uaccess.h:
copy_from_user (void* to, const void __user * from, unsigned long n);

Просто так взять и скопировать данные от пользователя (модификатор __user) нельзя, нужно пользоваться этой функций
(такие данные приходят как формальный параметр в fortune_write)
Возвращает 0 при успехе, иначе - количество необработанных байт
// По-хорошему, как я понимаю, её надо юзать всегда для работы с данными от пользователя, но мне было лень

linux/string.h:
int sprintf ( char * str, const char * format, ... ) - аналог функции из стандартной библиотеки
В fortune_read() запись по указателю page - вывод при попытке считывания (например, cat /proc/lab3 будет возвращать то, что вы туда запишите)

// А, да, не забудьте поменять имя в MODULE_AUTHOR :3

Мануал, по которому делалась лаба: http://www.ibm.com/developerworks/ru/library/l-proc/